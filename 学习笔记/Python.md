# Python 学习笔记
## 有关 python 解释器：
1. 解释器的概述
   -  python 的运行单元是**python 环境**，而python 解释器是一个 python环境的**核心**，环境各种安装的包均依赖于解释器，所以我们一般使用的虚拟环境工具，如 conda 环境，本质上就是对 python 解释器和其附属的所有包进行隔离，每个环境互不影响。python 解释器在计算机中一般位于 python 环境中的 **bin文件夹**
   -  python 解释器的**源代码**是一个 **C 语言编写的程序**，通常称为 **CPython**，我们下载的python 解释器通常是**预编译好的可执行文件**(python解释器真正的本质)，python 程序运行时接受输入的程序，将其转换为机器码，由机器处理之后输出。由于 C 语言最为高效且最接近机器底层，顾被选用作为 python 的解释器源代码的编写语言。
   -  但是运行 python 程序也需要依赖我们自己操作系统中的 C编译器，当python 项目中包含了C 拓展模块、或者一些对性能要求高的 python 库(如 numpy、Pandas等)其核心代码往往由 C 编写，这时就需要使用 C 编译器来编译， 在各个操作系统中并不相同，Linux 中是 **GCC**，MacOS 中是 **Clang**，Windows 中则为**Microsoft Visual C++ (MSVC)**
2. 如何使用 python 解释器
   1. 唤出解释器：
     - 终端 python 解释器的工作特性类似于UNIX shell,提供了一种交互方式，一次只能输入一条指令，即输即解释，可以通过在终端直接输入`python`来启动，启动之后即可输入指令执行，退出则是 control-D 或输入`exit()`，也可以直接在终端输入`python -c 'command'`来直接执行 command 指令
     - 关于如何执行 python 文件：
    2. 交互模式
## 有关 python 环境
1. python 环境是指python 程序运行所需的一系列功能库的配置，这些库依赖于一个核心的 python 解释器而存在，与解释器捆绑在一起。可以说，python 程序的执行成功与否，一半取决于代码内部逻辑，另一半则取决于 python 环境的配置是否合适。
2. 关于如何创建与管理 python 环境
   - **CONDA 环境**：
      - conda 的功能：
         - conda主要被用作 **python 环境管理器**，主要作用是针对不同的项目，创建、管理多个不同的 python 环境，以避免多个项目使用同一环境时会出现的依赖冲突问题
      - 安装 conda：
         - windows：
            - 下载地址：[Anaconda](https://www.anaconda.com/products/distribution)
            - 安装：双击下载的安装包，一路下一步即可
         - Ubuntu：
            - `wget https://repo.anaconda.com/anaconda/Anaconda3-latest-Linux-x86_64.sh`，终端输入，获取最新的Anaconda安装包
            - `bash XXX.sh`，XXX 替换为下载得到的安装包名，安装Anaconda
            - `source ~/.bashrc`,更新环境变量，使其 conda 环境生效
            - `conda --version`,验证安装是否成功
      - conda 的使用技巧：
         - 对python环境整体的操作：
            - `conda env list`:显示当前所有的 python 环境，标星号*表示当前环境
            - `conda create --name env_name python=3.8`:创建一个名为 env_name 的 python3.8 环墶
            - `conda env remove --name env_name`:删除名为 env_name 的 python 环境
            - `conda create --name new_env --clone old_env`：复制一个 python 环境
            - `conda activate env_name`:激活名为 env_name 的 python 环境
            - `conda deactivate`:退出当前 python 环境 
         - 在当前python环境内部的操作：
            - `conda list`:显示当前conda 环境中所有安装所有的 python 包，**包括通过 pip 安装的**，而且会在最后显示来源<pypi>，虽然pip list 只会显示通过 pip 安装的包，但还是推荐只要是涉及包的操作还是使用 pip，因为快且方便，只要全部都用 pip 安装，pip list 显示的包就是你环境中全部的包
            - `which python`:显示当前 python 环境的解释器路径
   - **PIP 包管理器** ：
      - pip 的功能：
         - pip 是 **python 包管理器**，主要作用是下载、安装、卸载 python 包 ，我个人一般喜欢搭配 conda 使用，即使用 conda 管理 python 环境，使用 pip 管理 python 包。使用 conda 创建好 python 环境后，一般会自动安装 pip 包管理器
      - pip 的使用：
         - `pip install package_name`:安装名为 package_name 的 python 包
         - `pip install package_name -i https://pypi.tuna.tsinghua.edu.cn/simple`:使用清华镜像源安装名为 package_name 的 python 包
         - `pip uninstall package_name`:卸载名为 package_name 的 python 包
         - `pip list`:显示当前 python 环境中所有的 python 包
         - `pip freeze > requirements.txt`:将当前 python 环境中所有的 python 包导出到 requirements.txt 文件中
         - `pip install -r requirements.txt`:根据 requirements.txt 文件中的包名，安装所有的 python 包
## 有关 python 的文件结构
1. 脚本(Script)：通常是具有完整的执行逻辑，可以单独实现完整或部分功能的程序文件
   - 特征：往往包含`if __name__==__main:`这样的语句，表示只有这个脚本被单独执行时，才会执行下面的逻辑任务。这是为了使得这个脚本既能够单独作为一个脚本执行，也可以作为一个模块将其中定义的函数、变量、类等被其他程序引用，提高脚本的可重复利用性。
2. 模块(Module)：通常是定义了很多函数、变量、类，主要用来被其他脚本或模块调用的程序文件
   - 关于模块(或脚本，本质相同)的属性：
     - __name__:模块的名称，作为脚本直接运行时，为**__main__**,被导入时，为模块名
     - __file__:模块在系统中的绝对路径
     - __package__:模块的父包名
     - __all__:模块的公共接口，当该模块被其他模块或脚本导入时，如果导入语句出现了`import *`，那么将只会将该模块中__all__属性包含的类、函数、变量导入其命名空间，其余不会导入
3. 包(Package)：包含python模块和脚本文件
   - python包的重要标志是包内含有**__init__.py**文件，此文件可以为空，也可以写上一些逻辑语句，使用最多的是直接将本包中的**某个模块中**的类、函数、变量等直接导入本包的命名空间，这样被导入的类、函数、变量在包中的层级和模块本身相当
4. 库(Library)：由模块和包构成，在所针对的功能上更加具有完整性，可以分为**标准库**和**第三方库**
   - 标准库：是 python 内置的一些模块和包，分为**内置方法**、**内置模块**和**纯 Python 模块和包**
      - 内置方法和函数：针对 python 内置类型（字符串、列表、字典、元组等）可使用的方法，被直接编译进了 python 解释器，在使用时直接使用即可，不必 import 导入，使用效率最高
      - 内置模块：是最常用的一些 python 模块，由 C编写，**直接编译进了解释器**，以实现较高的使用效率，包含：sys、os、time、math等，但是使用时仍需导入，这是为了代码的可读性与可维护性
      - 纯 Python 模块和包：较常用的模块和包，由 python 编写，被存放在该 python环境所在文件夹的**lib/python3.x**路径下，散装，使用时需要导入，运行时需要单独编译
   - 第三方库：后期用户自行下载安装的 python 库，被存放在**lib/python3.x/site-packages**路径下，如通过pip 和 conda 下载安装的库
5. 关于脚本、模块、包、库的导入
   - 关于导入的本质：无论是`from A import B`还是`import B`，本质上都是将 B 导入到**当前模块或脚本的命名空间**中，从此在当前模块或脚本的逻辑时间内，通过访问B 这个字符就可以访问 B 原先代表的包、模块、脚本、类、函数、变量等
   - 绝对导入: 用的更多
      - 关于搜索路径：程序会依次在**内置模块**、**sys.path** 列表中查找目标，其中sys.path列表形状是[**当前程序所在目录**，**当前python 环境标准库目录**，**当前python 环境动态链接库目录**，**当前python 环境第三方库目录**，**环境变量 PYTHONPATH包含的目录**]
   - 相对导入: 特征为出现`.A`或`..A`等，作用是避免自己的包内的某个模块和sys.path所有路径中的已有模块发生名称冲突
      - .表示当前目录，..表示上级目录，以此类推
      - 关于搜索路径: 此时python**不会**在内置模块和sys.path中查找A,相对导入的文件查找原理是：首先获取本文件的**__file__属性**，即本文件在系统中的绝对路径，然后获取**__package__属性**，这个是本文件的父包名，通过这两条信息，再结合 **.** 、**..**、**...**等相对位置信息，python 就知道改到哪里去找后面的A，可以看出这样可以使得查找时仅关注本项目中的文件，避免和其余文件重名，提高可移植性。
      - 使用条件：
        - 只能在**被调用的模块**中使用。不能在顶级脚本中使用，即不能在一个单独运行的python 程序中使用相对导入，因为此时该脚本的__package__属性为 None，除非在运行顶级脚本时使用`python -m `，才可以使得python 将该脚本作为包的一部分来执行
        - 只能在**包内**使用。即父目录中一定得有__init__.py 文件，使得父目录成为一个 python 包，但是导入对象，即..A 中的 A 不一定得是 python包，不过为了项目的整体性，建议将每个文件夹都处理为 python 包。








## python 的语言
1. 万物皆对象：python中所有可以操作的实体都是对象，python本质上为面向对象编程而生。
   - **两大核心关系**：
     - **父类-子类关系**：以继承为纽带链接而成的关系链条，除实例对象之外和object的所有对象都有其父类，object站在本关系链的顶端，他是除实例对象和自身之外的所有对象的超类(顶层父类)
     - **类型-实例关系**：以实例化为纽带链接而成的关系链条，所有对象都有其类型，type站在本关系链的顶端，他是所有对象(包括自身)的元类(顶层类型)。由类型-实例关系，python中的对象分布展现为**三层体系**：
       - 顶层**元类对象**: 即type，作为元类对象，定义了其他所有对象最基本的行为
       - 中层**类型对象**: 即所有由元类对象实例化而来的对象，包括object，在本层中，object为超类，我们的自定义类型、数据(int、str、list等)都继承自object
       - 底层**实例对象**：即所有由类型对象实例化而来的对象，如`a=A()`而来的a、整型数据123、列表型数据[1,2,3]等，其本身已不再是一个类型对象，没有父类，也不能再实例化
   - **object和type**：object的本质是一个类型对象，type的本质是一个元类对象。因为object是除实例对象和自身之外的所有对象的超类，所以type继承自object，且object自身没有父类；因为type是所有对象的元类，所以object由type实例化而来，且type由自身实例化而来
   - 自定义新元类:我们在使用`class`关键字创建一个类型对象的时候，需要指定两个参数，一个是他的父类，另一个是他的元类，默认将object作为父类，type作为元类，由于类型对象的行为最终由元类直接决定，我们可以创建一个type元类的子类作为新元类，并对其中的行为做修改，以此新元类实例化类型对象，就可以统一管理和控制多个类的行为，同时不会影响其他以type为元类的类型对象。类似的效果也可以通过重写由type实例化而来的实例对象中的属性方法实现，后者更简单直接，适合单个类或少量类的使用场景。
2. 数据：
   - 数值类型
      - 整数(int)：指没有小数部分的数，python 中的整数大小没有任何限制(只要内存允许)。表示方法分为十进制(正常数字如 123)、二进制(0b 开头，如 0b1010)、八进制(0o开头，如 0o12)、十六进制(0x 开头，如 0xA)
      - 浮点数(float)：有小数部分的数，python 中最多可以精确到**小数点后 15-17 位**，再下一位则进行舍入。表示方法分为十进制和科学计数法，其中科学计数法以 e 或 E 后的数字表示指数位，如 1.23e-5 表示 1.23*10^-5
      - 复数(complex):指具有实部和虚部的数值，形式为 a+bj；具有实部属性.real 和虚部属性.imag
   - 可迭代类型：
      - 字符串
      - 列表
      - 元组
      - 集合(本质是无序的，只能通过for访问，不支持索引访问)
      - 字典(本质是无序的，只能通过for或键来访问，不支持序列访问)
   - 特殊类型
      - 布尔值
      - 空值
3. 语句
   - 基本组成单元
      - 关键字：
         - **False**:布尔值，表示假
         - **True**:布尔值，表示真
         - **None**:表示空值
         - **and**:逻辑运算符，表示与
         - **or**:逻辑运算符，表示或
         - **not**:逻辑运算符，表示非
         - **in**:两个用法，第一个为成员运算符：即检查一个值是否在一个序列中；第二个为循环迭代，用于 for 循环中遍历一个序列
         - **is**:身份运算符，用于比较两个对象的内存地址
         - **raise**:用于在程序中主动引起异常
         - **as**:用于给模块或异常起别名
         - **assert**:用于调试的断言语句，用法是`assert 条件 错误消息`，如果条件为真，则继续执行，如果为否，则引发AssertionError异常
         - **async**:表示定义异步函数，定义方法是`async def name():`通常在函数中使用await暂停此异步函数的执行，等待其他异步操作完成
         - **await**:只能搭配async在异步函数中使用，用于暂停异步函数的执行，等待另一个异步函数的完成
         - **del**:用于删除变量释放内存、列表中的元素、字典中的键值对等，del了之后再访问会引发 NameError
         - **while**:用于循环，当条件为真时继续循环，条件为假时退出循环
         - **for**:用于循环中遍历序列或其他可迭代对象
         - **break**:用于终止循环语句，直接跳出当前的 for 或 while 循环
         - **continue**:用于跳过当前循环的剩余部分，开启下一次循环
         - **class**:用于定义类
         - **def**:用于定义函数
         - **return**:用于从函数中返回，其后可以跟一个字面量，也可以为空
         - **lambda**:用于创建匿名函数，形式为`name=lamda 参数1,参数2，... : 表达式 `，使用时`name(参数1,参数2，... )`即可,只能创建简单函数，复杂函数需要使用def创建
         - **if**:用在条件语句中，表示当条件为真时，执行怎么样的操作
         - **elif**:跟在条件语句 if 之后，表示"否则如果"，只有当前面的 if 不成立时才会执行 elif 下的语句
         - **else**:用在条件语句 if 或 elif 之后，表示否则，只有当前面的所有条件都不符合时才会执行 else 下的语句
         - **try**:尝试执行可能包含错误的代码，即使遇到错误，也会被后面的except代码块捕获，代码也会继续执行，不会终止
         - **except**:用于捕获和处理在 try 语句中遇到的特定类型的异常
         - **finally**:用于定义在try 语句中遇到错误之后继续执行的代码
         - **from**:用于从模块或包中导入
         - **import**:用于将某模块或函数、变量、类导入当前命名空间，以便直接使用该名
         - **global**:用于定义全局变量
         - **nonlocal**:用于在内层嵌套函数中声名外层函数作用域中的变量
         - **pass**:用于占位，无实际意义
         - **with**:用于见哈资源管理，确保在块执行结束之后资源能够正确释放或清理
         - **yield**:用于定义生成器函数，每次调用yield时，函数会暂停并等待返回一个值，下一次迭代时从暂停的地方继续执行
      - 运算符
         - 算数运算
           - `+ `:加法运算
           - `-`：减法运算
           - `*`：乘法运算
           - `/`：除法运算
           - `//`：整除运算
           - `%`：取模(取余数)
           - `**`：幂运算
         - 比较运算
           - `==`: 等于
           - `!=`：不等于
           - `>`：大于
           - `<`：小于
           - `>=`：大于等于
           - `<=`：小于等于
         - 逻辑运算
           - `and`：与
           - `or`：或
           - `not`：非
         - 赋值运算
           - `=`：赋值
           - `+=`：加法赋值
           - `-=`：减法赋值
           - `*=`：乘法赋值
           - `/=`：除法赋值
           - `//=`：整除赋值
           - `%=`: 模赋值 
           - `**=`：幂赋值
         - 位运算：
           - `&`：按位与
           - `|`：按位或
           - `^`：按位异或
           - `~`：按位非
           - `<<`：左移
           - `>>`：右移
         - 成员运算
           - `in`：在指定序列中找到值返回True
           - `not in`：在指定序列中没找到值返回True
         - 身份运算
           - `is`：判断两个标识符是否引用同一对象
           - `is not`：判断你两个标识符是否引用不同对象
      - 分隔符：
         - `()`: 调用函数、定义元组、控制运算符优先级
         - `[]`：定义列表、访问列表元素、列表切片
         - `{}`：定义字典和集合
         - `,`：分隔函数参数、列表元素、元组元素
         - `:`：英译函数、类、条件语句、循环语句等代码块
         - `;`：同一行中分隔多个语句
         - `.`：访问对象的属性和方法
         - `''`和`""`：定义字符串
         - `\`：续行符，表示代码在下一行继续
      - 标识符：用于命名变量、函数、类或其他对象的名称，其命名规则为：
         - 只能包含**数字**、**字母**、**下划线**
         - 不能以数字开头
         - 区分大小写
         - 不能是关键字
      - 字面量：即python中所有包含的数据
      - 注释：用于在代码中添加说明性文字，分为单行注释和多行注释，单行注释以`#`开头，多行注释以三引号：`"""`或`'''`包围
   - 复合语句：
      - **if条件语句**：用于定义在某种条件成立下执行的代码块
        - 基本结构是：
        ```python
           if 条件测试：
              代码块
        ```
        - 条件测试：是紧跟if之后的表达式，形式多样，值为True或False，如果为True，则执行if之下的代码块，如果为False，则跳过其下的代码块
        - 单分支：只有一个if代码块存在
        - 双分支：即if else语句，如果if成立则执行if下的代码块，不成立则执行else下的代码块
        - 多分支
          - if else 多分支：else前有多个if，每个if条件独立判断，互不影响，只有当全部if条件都不满足时，在会执行else语句
          - if elif else 多分支：elif后的条件判断室友在前一个if或elif不成立的情况下才会执行，也就是说层层相扣，只有前面一个没有执行，后面才会被执行，如果前面有一个被执行，后面的都会直接跳过
        - 嵌套：就是在if之下的代码块中加入了另一些if条件语句，作用方式相同
      - **while循环**：用于定义在某种条件成立下执行的循环代码块
        - 基本结构是：
         ```python
            while 条件测试：
                  循环体
         ```
        - 条件测试：时紧跟while之后的表达式，形式多样，每次在执行while下的循环代码块之前都会先判断一下条件测试是否为True，若是则进入循环，若否则跳出循环
      - **for循环**：是一种迭代循环结构，用于遍历可迭代对象时执行的操作，对于一些无序但可迭代对象，如字典、集合，仅可使用for来访问
        - 基本结构是:
         ```python 
            for 变量 in 可迭代对象:
                循环体
         ```
        - 关于可迭代对象：这里的可迭代对象即上面pythoin数据中的可迭代类型，包含有序和无序数据类型，重点关注`range(start=0,stop,step=1)`函数，会返回一个**迭代器对象**，这个迭代器会依次次返回start到stop-1的数，步长为step
        - 关于变量：这里的变量是循环内部的局部变量，每次循环开始之后会被重新赋值为可迭代对象中的当前迭代值
      - **try**
      - **with**
      - **match**
4. 自定义类型
   - 地位：所有类型对象(包括元类对象)可以依据其内部定义的**属性**和**方法**进行实例化生成其他对象，自定义类型对象是由用户自行定义的类型对象，我们由面向对象编程的思想将问题的解决转以对象为中心，将任务拆分并分配给了功能不同、各司其职的类型对象，各自解决，随着我们对类内属性和方法的补充，其相应功能越来越完整，问题也就好解决了
   - 结构：
     - ```python
       class Animal():
            number=0                               # 类变量
            def __init__(self,name,age,color):     # 初始化方法
                self.name=name                     # 实例属性
                self.age=age                       # 实例属性
                self.color=color                   # 实例属性
                self.__secret=None                 # 私有实例属性
            def introduce(self):                   # 实例方法
                print(f"Hi,我的名字是小动物{self.name},wp")
            def sit(self):                         # 实例方法
                print(f"我坐下了!")
            def eat(self):                         # 实例方法
                print(f"我正在吃饭")
            def make_sound(self):                  # 抽象实例方法
                pass
            def set_secret(self,secret):           # 私有实例属性对外的接口
                self.__secret=secret
            def __tell_the_secret(self):           # 私有实例方法
                print(f"我的秘密是：{self.__secret}")
            @classmethod                           # 类方法
            def change_number(cls):
                cls.number+=1
            @staticmethod                          # 静态方法,工具函数
            def add(a,b):
                return (a+b)

       class Cat(Animal):
          def __init__(self,name,age,color,secret):
              super().__init__(name,age,color)     # 父类初始化
              self.change_number()
              self.set_secret(secret)
          def make_sound(self):                    # 重新定义的实例方法
              print("喵喵喵")
          def introduce(self):                     # 重新定义的实例方法
              print(f"我的名字是小猫{self.name}")
          def tell_the_secret(self):               # 新的实例方法,同时也是私有属性对外的接口
              print(f"告诉大家，我的秘密是{self.__secret}")

       class Dog(Animal):
          def __init__(self,name,age,color,secret):
              super().__init__(name,age,color)     # 父类初始化
              self.change_number()                 # 私有实例属性
              self.__secret=secret
          def make_sound(self):                    # 重新定义的实例方法
              print("汪汪汪")
          def introduce(self):                     # 重新定义的实例方法
              print(f"我的名字是小狗{self.name}")
          def tell_the_secret(self):               # 新的实例方法,同时也是私有属性对外的接口
              print(f"告诉大家，我的秘密是{self.__secret}")

       cat1=Cat("小红",6,"red","我喜欢小绿")
       cat2=Cat("小绿",7,"green","我喜欢小红")
       cat3=Cat("小蓝",7,"blue","我是小丑")
       dog1=Dog("小白",8,"white","我才是小丑")
      ```
     - **类名**: 一般是开头第一个字母大写的标识符
     - **类属性**:类型对象自己的属性，与类本身以及其下所有实例对象共享，用于记录与类本身相关的特征。一般直接写在类定义中的`class 类名():`之下，推荐使用类对象名调用，也可以使用实例对象名调用
     - **类方法**: 类型对象自己的方法，用来修改类属性，使用`@classmethod`装饰器定义，指定参数是`cls`,表示类本身，推荐使用类对象名调用，也可以使用实例对象名调用
     - **实例属性**: 实例对象单独具有的属性，可以使用实例对象名访问和修改
     - **实例方法**: 实例对象单独具有的方法，指定参数是`self`，表示实例对象本身，可以使用实例对象名调用
     - **静态方法**: 大多数为工具箱类型的方法，不与类对象或实例对象本身有依赖关系，也就不会用到任何类属性、类方法、实例属性、实例方法，但是可以实现一定的工具功能，一般使用`@staticmethod`定义，可以通过类名或实例对象名调用
     - **私有属性**: 只能在**类代码块内**访问和修改，同时**无法被子类继承**。一般在属性`attribute`名前加双下划线`__`，其原理是 python 会自动将此属性在类内改名为`_Classname__attribute`形式，导致其在类外使用原来的`__attribute`访问不了，但可以使用`_Classname__attribute`访问。这个改名过程只会在类代码块内发生一次，如果在类代码块外为其增加一个`__attribute`属性，则不会进行改名，依然可以使用该名称访问。私有属性可以是类属性或实例属性
     - **私有方法**: 只能在**类代码块内**调用，同时**无法被子类继承**。一般在方法名前加双下划线`__`，原理同私有属性。私有方法可以是类方法或实例方法或静态方法
     - **受保护属性**：只能在**类和子类代码块内**访问和修改(约定)，一般是属性名前加单下划线`_`
     - **受保护方法**：只能在**类和子类代码块内**调用(约定)，一般是方法名前加单下划线`_`
   - 特点：
     - 封装:是将属性(数据)和方法(操作数据的函数)绑定在一起，并隐藏内部实现细节的方法。封装分为两层，第一层，即类型对象的形式本身，将属性和方法绑定到某类实例对象上，以提高代码编写效率与复用性；第二层，即类内将一些属性和方法私有化，隐藏起来，仅对外提供一些公共接口供执行某些有限的操作，避免了对内部数据不必要的影响，提高代码可维护性
     - 继承:即一个类(子类)可以获取另一个类(父类)的属性和方法，同时也可以在子类中添加自己特定的属性和方法，这样就可以做到对父类的代码进行复用、修改和拓展。继承有以下特点：
       - 父类中的所有属性和方法(私有除外)都被继承到子类中
       - 子类定义的属性和方法中与父类中不重名的都独属于子类
       - **重写**：子类中可以定义与父类中重名的属性或方法，以实现在子类中对父类方法进行重新定义，但是在父类中不发生改变
       - **调用**：子类中若想要调用重写之前的父类中某属性或方法，则可以使用`super()`函数，会返回一个父类实例对象
     - 多态:
   - 内置属性和方法：所有以type为元类、以object为父类的类型对象都具有相同的初始内置属性和方法，只不过由于子类行为可以在父类基础上做重写和扩展，一些内置的类型对象如int、str、list的内置方法都做了相应改动，但是自定义类型依然保有最初始的基因。内置方法和属性开头和结尾都是双下划线`__`
     - 内置方法：
       - `__init__(self, ...)`: 初始化方法，创建实例对象时调用
       - `__new__(cls, ...)`：创建并返回一个新的实例对象
       - `__len__(self)`：返回对象的长度
       - `__getitem__(self，key)`：返回指定键的值
       - `__iter__(self)`：返回对象的迭代器
       - `__next__(self)`：返回迭代器的下一个值
       - `__del__(self)`
       - `__repr__(self)`
       - `__str__(self)`
       - `__bytes__(self)`
       - `__format__(self,format_spec)`
       - `__lt__(self,other)`
       - `__le__(self,other)`
       - `__eq__(self,other)`
       - `__ne__(self,other)`
       - `__gt__(self,other)`
       - `__ge__(self,other)`
       - `__hash__(self)`
       - `__bool__(self)`
       - `__call__(self,...)`
       - `__setitem__(self,key,value)`
       - `__delitem__(self,key)`
       - `__contains__(self,item)`
       - `__add__(self,other)`
       - `__sub__(self,other)`
       - `__mul__(self,other)`
       - `__truediv__(self,other)`
       - `__floordiv__(self,other)`
       - `__mod__(self,other)`
       - `__pow__(self,other,modulo=None)`
       - `__and__(self,other)`
       - `__or__(self,other)`
       - `__xor__(self,other)`
       - `__lshift__(self,other)`
       - `__rshift__(self,other)`
       - `__iadd__(self,other)`
       - `__isub__(self,other)`
       - `__imul__(self,other)`
       - `__itruediv__(self,other)`
       - `__ifloordiv__(self,other)`
       - `__imod__(self,other)`
       - `__ipow__(self,other)`
       - `__iand__(self,other)`
       - `__ior__(self,other)`
       - `__ixor__(self,other)`
       - `__ilshift__(self,other)`
       - `__irshift__(self,other)`
       - `__neg__(self,other)`
       - `__pos__(self,other)`
       - `__abs__(self,other)`
       - `__invert__(self)`
       - `__complex__(self)`
       - `__int__(self)`
       - `__float__(self)`
       - `__round__(self,n=None)`
       - `__index__(self)`
       - `__enter__(self)`
       - `__exit__(self,exc_type,exc_value,traceback)`
     - 内置属性：
       - `__dict__`：对于实例对象，返回包含该实例所有属性名、属性值键值对的字典；对于类型对象，返回包含该类型所有属性名、属性值、方法名、方法函数说明的键值对
       - `__class__`：对于实例对象，返回将其直接实例化的类型对象，对于类型对象，返回其元类对象
       - `__module__`：对于类型对象，返回定义该类型对象的模块名称
       - `__doc__`：对于类型对象，返回其的文档字符串
       - `__name__`：对于类型对象，返回其的名称
       - `__bases__`：对于类型对象，返回其所有父类的元组

5. 
6. 标准库
   - 内置方法和函数
      - `id(object)`:获取对象的内存地址
      - `type(object)`:获取实例对象的类
      - `len(iterable)`:返回可迭代对象的长度;**iterable**为可迭代对象如列表、元组、字典等
      - `sum(list)`:对列表中的元素求和
      - `sorted(iterable, key=None, reverse=False)`:对可迭代对象进行排序；**iterable**为可迭代对象如列表、元组、字典等；**key**：是一个函数选项，用于自定义排序；**reverse**为布尔值，True为降序排序，False为升序排序
      - `complex(a,b)`:创建复数;使用方法：complex(a,b),即创建 a+bj
      - `super()`:在类继承中返回一个父类对象，以在子类中使用重写之前的父类中的属性或方法
      - `hasattr(object)`: 查看对象是否含有属性
      - `.conjugate()`：创建共轭复数；使用方法:a=b.conjugate(),其中 b 为某已知复数
   - 内置模块和纯python包
      - **sys**：提供python解释器与**系统交互**有关的变量
        - `.argv`：命令行参数列表
        - `.path`：模块搜索路径列表
        - `.platform`： 当前运行的操作系统平台
        - `.version`: 当前环境中Python解释器版本信息
      - **os**：提供**文件处理**的函数和方法
        - `getcwd()`:获取当前的绝对工作路径
        - `listdir(path)`:输入任意路径，返回该路径下所有文件和目录组成的列表
        - `walk(path)`:
        - `rmkdir(path)`:输入任意路径，删除指定路径下的文件夹；只能删除空文件夹
        - `remove(path)`:输入任意文件的路径，删除指定路径的文件
        - path子模块：
          - `exists(path)`:输入任意文件夹或文件的绝对路径，返回该指定路径下的文件夹或文件是否存在，存在返回True，不存在返回False
          - `mkdir(path，exist_ok=False)`:输入任意文件夹绝对路径，在其目录路径下创建指定文件名的单个单层文件夹；**exist_ok**为布尔值，False 表示如果创建前已存在该文件夹则会报错，True 则表示可以出现上述情况
          - `mkdirs(path，exist_ok=False)`：输入任意文件夹绝对路径，在其目录路径下创建指定文件名的多个递归文件夹；**exist_ok**为布尔值，False 表示如果创建前已存在该文件夹则会报错，True 则表示可以出现上述情况
          - `join(path1,path2)`:传入两个路径，拼接起来形成新的完整路径
          - `split(path)`:传入任意文件的绝对路径，返回将其拆分成(目录路径,文件名)的元组
          - `dirname(path)`:传入任意文件绝对路径，只获取其目录路径
          - `basename(path)`:传入任意文件绝对路径，只获取其文件名
          - `isdir(path)`：传入任意文件绝对路径，判断起是否是文件夹
          - `isfile(path)`:传入任意文件绝对路径，判断其是否是文件
          - `abspath(path)`:输入任意文件的相对路径，将其和当前的目录路径相整合组成绝对路径
      - **random**：提供随机数生成的功能
   - 纯 python 模块和包
7. 常用的第三方库：
   - **Matplotlib** ：常用的绘图库
     - pyplot模块：
       - `subplot(row,col,id)`:在一个图形窗口中创建多个子图，**row**、**col**分别是子图排列的行数和列数，**id**为此子图的id
       - `plot(x,y,label,color=None,linestyle='-',marker='o')`:绘制连续二维曲线；**x**为存放x轴数据的列表，**y**为存放y轴数据的列表，(其实也可以只输入一个列表数据，此时plot内部自动将输入列表作为y值，以数据索引为x轴)**label**是对这根曲线的命名,**color**为线的颜色，可指定'r'、'g'、'b'，**linestyle**为线形,'-'为实线，'--'为虚线，**marker**指定数据点的形状，'o'为圆点，'s'为方块
       - `scatter(x,y,label=Nnoe,color=None,marker='o')`:绘制散点图，**x**为存放x轴数据的列表，**y**为存放y轴数据的列表，(这里注意和plot区分：此处必须指定x和y两者，否则无法绘制)**label**是对这根曲线的命名,**color**为线的颜色，可指定'r'、'g'、'b'，**marker**指定数据点的形状，'o'为圆点，'s'为方块，,'*'为星形,'+'为加号,'v'为下三角
       - `hist(x,bins,range=(min,max),density=False,cumulative=False,color=None,edgecolor=None,alpha=None)`：绘制直方图，**x**:输入列表,**bins**：箱的数量，当指定数字时，表示将数据分成几个部分，当指定列表[a,b,c,d,e]时，表示将数据按照[a,b]、[b,c]、[c,d]、[d,e]分组,**range**表示接受的数据范围,形状是一个元组(x,y),表示只有这个范围内的数据才会被包含在直方图内,**density**表示是否绘制频率密度分布，True为是，False为否,**cumulative**表示是否绘制累计直方图，True为是，False为否,**color**为直方图颜色,**edgecolor**为直方图边缘颜色,**alpha**为直方图透明度
       - `title(label)`:图像标题
       - `xlabel(label)`:x轴的标签
       - `ylabel(label)`:y轴的标签
       - `legend()`:显示图例
       - `tight_layout()`:自动调整子图间距，使其排列均匀
       - `show()`显示图像
       - `savefig(path)`：输入图像的绝对路径，即可在相应目录路径下保存该文件名的图片。
       - `clf()`:清除目前为止的绘图，用于在一段代码中绘制多幅独立图像
   - **loguru**：任务日志记录库
     - 下载：`pip install luguru`
     - 导入:`from loguru import logger`，导入一个预定义好的全局 **logger** 日志对象
     - 日志级别：由低到高：**trace**(记录非常详细的调试信息)>>>**debug**(记录调试信息)>>>**info**(记录一般信息，如开始、变量值的输出、结束等)>>>**success**(记录成功操作的信息)>>>**warnning**(记录警告信息，如资源不足)>>>**error**(记录错误信息，如异常捕获，操作失败)>>>**critical**(记录相当严重的错误信息，如系统崩溃，数据丢失)
     - 创建日志文件：`logger.add("path/to/file.log", rotation="5000 MB",level="INFO") `：**rotation**:当日志文件的大小超过多少时创建一个新的日志文件；**level**:高于这级别的日志才会被写入 log 文件
     - 日志记录：
       - `logger.debug("这是一个调试日志")`
       - `logger.info("这是一个信息日志")`
       - `logger.warning("这是一个警告日志")`
       - `logger.error("这是一个错误日志")`
       - `logger.critical("这是一个严重错误日志")`
   - **sympy**：方程求解库
     - `symbols(name,real=None,positive=None)`:用于定义变量的函数，返回一个变量对象，**name**:表示变量名，**real**:表示是否为一定是实数，**positive**:表示是否一定是正数
     - `Eq(,)`:是一个定义方程对象的类，返回一个可求解的方程对象，输入参数分别是等式的两边
     - `solve(equation_name，variables_name)`：解析求解函数，用于获取解析解，返回包含所有符号解的列表，**equation_name**：之前定义好的方程对象
     - `nsolve(equation_name,variables_name,Initial)`：数值求解函数，用于获取数值解，只返回一个解，且与迭代初值相关**equation_name**：之前定义好的方程对象，**variables_name**:变量对象，**Initial**：迭代初值
8. 错误与异常  

